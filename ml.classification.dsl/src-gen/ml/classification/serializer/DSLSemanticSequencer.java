/*
 * generated by Xtext 2.23.0
 */
package ml.classification.serializer;

import com.google.inject.Inject;
import java.util.Set;
import ml.classification.dSL.Algo_choose;
import ml.classification.dSL.Assign;
import ml.classification.dSL.Column;
import ml.classification.dSL.DSLPackage;
import ml.classification.dSL.Expression;
import ml.classification.dSL.ML;
import ml.classification.dSL.Primitive;
import ml.classification.dSL.Print;
import ml.classification.dSL.Read;
import ml.classification.dSL.Statement;
import ml.classification.dSL.Strategy_choose;
import ml.classification.dSL.Use_Metric;
import ml.classification.services.DSLGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DSLPackage.ALGO_CHOOSE:
				sequence_Algo_choose(context, (Algo_choose) semanticObject); 
				return; 
			case DSLPackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case DSLPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case DSLPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case DSLPackage.ML:
				sequence_ML(context, (ML) semanticObject); 
				return; 
			case DSLPackage.PRIMITIVE:
				sequence_Primitive(context, (Primitive) semanticObject); 
				return; 
			case DSLPackage.PRINT:
				sequence_Print(context, (Print) semanticObject); 
				return; 
			case DSLPackage.READ:
				sequence_Read(context, (Read) semanticObject); 
				return; 
			case DSLPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case DSLPackage.STRATEGY_CHOOSE:
				sequence_Strategy_choose(context, (Strategy_choose) semanticObject); 
				return; 
			case DSLPackage.USE_METRIC:
				sequence_Use_Metric(context, (Use_Metric) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Algo_choose returns Algo_choose
	 *
	 * Constraint:
	 *     algorithm=ALGO_NAME
	 */
	protected void sequence_Algo_choose(ISerializationContext context, Algo_choose semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.ALGO_CHOOSE__ALGORITHM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.ALGO_CHOOSE__ALGORITHM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAlgo_chooseAccess().getAlgorithmALGO_NAMETerminalRuleCall_1_0(), semanticObject.getAlgorithm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assign returns Assign
	 *
	 * Constraint:
	 *     (varname=ID assign_value=Expression)
	 */
	protected void sequence_Assign(ISerializationContext context, Assign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.ASSIGN__VARNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.ASSIGN__VARNAME));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.ASSIGN__ASSIGN_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.ASSIGN__ASSIGN_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignAccess().getVarnameIDTerminalRuleCall_0_0(), semanticObject.getVarname());
		feeder.accept(grammarAccess.getAssignAccess().getAssign_valueExpressionParserRuleCall_2_0(), semanticObject.getAssign_value());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Column returns Column
	 *
	 * Constraint:
	 *     (use+=INT+ | unuse+=INT+ | predict=INT)
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (expr_prim=Primitive | expr_const=Constant)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ML returns ML
	 *
	 * Constraint:
	 *     (statements+=Statement* statements+=Statement)
	 */
	protected void sequence_ML(ISerializationContext context, ML semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Primitive returns Primitive
	 *
	 * Constraint:
	 *     (
	 *         print=Print | 
	 *         algo_choose=Algo_choose | 
	 *         read=Read | 
	 *         strategy_choose=Strategy_choose | 
	 *         column=Column | 
	 *         use_metric=Use_Metric | 
	 *         predict=Predict
	 *     )
	 */
	protected void sequence_Primitive(ISerializationContext context, Primitive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Print returns Print
	 *
	 * Constraint:
	 *     print=Constant
	 */
	protected void sequence_Print(ISerializationContext context, Print semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.PRINT__PRINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.PRINT__PRINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintAccess().getPrintConstantParserRuleCall_1_0(), semanticObject.getPrint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Read returns Read
	 *
	 * Constraint:
	 *     (path=STRING separator=SEP?)
	 */
	protected void sequence_Read(ISerializationContext context, Read semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (assign=Assign | primitive=Primitive)
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Strategy_choose returns Strategy_choose
	 *
	 * Constraint:
	 *     ((strategy='train_test' ratio=DOUBLE) | (strategy='cross_valid' nb=INT?))
	 */
	protected void sequence_Strategy_choose(ISerializationContext context, Strategy_choose semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Use_Metric returns Use_Metric
	 *
	 * Constraint:
	 *     metric=METRIC
	 */
	protected void sequence_Use_Metric(ISerializationContext context, Use_Metric semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.USE_METRIC__METRIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.USE_METRIC__METRIC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUse_MetricAccess().getMetricMETRICTerminalRuleCall_1_0(), semanticObject.getMetric());
		feeder.finish();
	}
	
	
}
