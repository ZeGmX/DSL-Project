/*
 * generated by Xtext 2.19.0
 */
package ml.classification.validation

import ml.classification.dSL.*
import org.eclipse.xtext.validation.Check
import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*
import org.eclipse.emf.common.util.EList
import ml.classification.dSL.Assign

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
 
 
class DSLValidator extends AbstractDSLValidator {
	
	public static val FORWARD_REFERENCE = "ml.classification.dsl.ForwardReference"
	public static val WRONG_TYPE = "ml.classification.dsl.WrongType"


	def static variablesDefinedBefore(Statement s, Constant variable) {
		val allStatements = s.getContainerOfType(typeof(ML)).statements
		val containingStatement = allStatements.findFirst[isAncestor(it, s)]
		val statementsList = allStatements.subList(0,allStatements.indexOf(containingStatement))
		
		for (var i = 0; i<statementsList.size(); i++)
		{
			val currentStatement=statementsList.get(i)
			
			if (currentStatement.assign !== null)
			{
				val currentVarName = currentStatement.assign.varname
				
				if (currentVarName == variable.varRef)
				{
						return true
				}
			}
		}
		
		return false
		
	}

	@Check
	def checkForwardReference(Statement statement) {
			if (statement.assign !== null)
			{
				if (statement.assign.assign_value.expr_const!== null)
				{
					if (statement.assign.assign_value.expr_const.varRef !== null)
					{
						var variable = statement.assign.assign_value.expr_const.varRef
						
						if (!variablesDefinedBefore(statement,statement.assign.assign_value.expr_const))
						{
							error("variable forward reference not allowed: '"+ variable + "'",statement, DSLPackage::eINSTANCE.statement_Assign,FORWARD_REFERENCE, variable)
						}
					}
				}
			}
	}
	
	def boolean checkTypePrimitive(Primitive primitive, Statement s){
		if (primitive.read!==null){
			val path=primitive.read.path
			val type="string"
			return path.constantInt === null && path.constantDouble === null && (checkTypeVarRef(path,type,s) || path.constantString !== null)

		}
		if (primitive.strategy_choose!==null){
			if(primitive.strategy_choose.strategy=="train_test"){
				val ratio =primitive.strategy_choose.ratio
				val type="double"
				return ratio.constantString === null && (checkTypeVarRef(ratio,type,s) || ratio.constantInt !== null || ratio.constantDouble !== null)
			}
			if (primitive.strategy_choose.strategy=="cross_valid"){
				val nb =primitive.strategy_choose.nb
				val type="int"
				return nb.constantString === null && nb.constantDouble === null && (checkTypeVarRef(nb,type,s) || nb.constantInt !== null)

			}
			
		}
		if (primitive.column!==null){
			if (primitive.column.use!==null){
				var columns = primitive.column.use
				for (var i =0; i<columns.size;i++){
					val nb = columns.get(i)
					if (nb.constantString!==null || nb.constantDouble!==null || !checkTypeVarRef(nb,"int",s)){
						return false
					}
				}
			}
			if (primitive.column.unuse!==null){
				var columns = primitive.column.unuse
				for (var i =0; i<columns.size;i++){
					val nb = columns.get(i)
					if (nb.constantString!==null || nb.constantDouble!==null || !checkTypeVarRef(nb,"int",s)){
						return false
					}
				}
			}
			if (primitive.column.predict!==null){
				var column = primitive.column.predict
				return column.constantString === null && column.constantDouble === null && (checkTypeVarRef(column,"int",s) || column.constantInt !== null)
			}
			return true
		}
		return true
	}
	
	
	def boolean checkTypeAssign(Assign assign, Statement s) {
		if (assign.assign_value.expr_prim!==null){
			return checkTypePrimitive(assign.assign_value.expr_prim,s)
		}
		return true
	}
	
	def boolean checkTypeVarRef(Constant variable, String type, Statement s) {
		val allStatements = s.getContainerOfType(typeof(ML)).statements
		val containingStatement = allStatements.findFirst[isAncestor(it, s)]
		val statementsList = allStatements.subList(0,allStatements.indexOf(containingStatement))
		
		for (var i = 0; i<statementsList.size(); i++)
		{
			val currentStatement=statementsList.get(i)
			
			if (currentStatement.assign !== null)
			{
				val currentVarName = currentStatement.assign.varname
				val currentVarRef = currentStatement.assign
				if (currentVarName == variable.varRef)
				{
					if (currentVarRef.assign_value.expr_const!==null){
						val const=currentVarRef.assign_value.expr_const
						switch (type){
							case "int":
								return const.constantInt!==null
							case "double":
								return const.constantDouble!==null || const.constantInt!==null
							case "string":
								return const.constantString!==null
						}
					}
				}
			}
		}
		return true
	}
	
	@Check
	def checkType(Statement statement) {
			if (statement.assign !== null)
			{
				if (!checkTypeAssign(statement.assign,statement)){
					error("wrong type",statement, DSLPackage::eINSTANCE.statement_Assign,WRONG_TYPE, statement.assign.varname)
				}
			}
			if (statement.primitive !== null)
			{
				if (!checkTypePrimitive(statement.primitive,statement))
				{
					error("wrong type",statement, DSLPackage::eINSTANCE.statement_Primitive,WRONG_TYPE)
				}
			}
			
	}
	
	
	
}
